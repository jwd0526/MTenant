// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: companies.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createCompany = `-- name: CreateCompany :one
INSERT INTO companies (
    name, domain, industry, street, city, state, country, postal_code,
    parent_company_id, custom_fields, company_size, employee_count, 
    annual_revenue, revenue_currency, created_by
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15
) RETURNING id, name, domain, industry, street, city, state, country, postal_code, parent_company_id, custom_fields, company_size, employee_count, annual_revenue, revenue_currency, created_by, updated_by, created_at, updated_at, deleted_at
`

type CreateCompanyParams struct {
	Name            string         `json:"name"`
	Domain          *string        `json:"domain"`
	Industry        *string        `json:"industry"`
	Street          *string        `json:"street"`
	City            *string        `json:"city"`
	State           *string        `json:"state"`
	Country         *string        `json:"country"`
	PostalCode      *string        `json:"postal_code"`
	ParentCompanyID *int32         `json:"parent_company_id"`
	CustomFields    []byte         `json:"custom_fields"`
	CompanySize     *string        `json:"company_size"`
	EmployeeCount   *int32         `json:"employee_count"`
	AnnualRevenue   pgtype.Numeric `json:"annual_revenue"`
	RevenueCurrency *string        `json:"revenue_currency"`
	CreatedBy       int32          `json:"created_by"`
}

func (q *Queries) CreateCompany(ctx context.Context, arg CreateCompanyParams) (Company, error) {
	row := q.db.QueryRow(ctx, createCompany,
		arg.Name,
		arg.Domain,
		arg.Industry,
		arg.Street,
		arg.City,
		arg.State,
		arg.Country,
		arg.PostalCode,
		arg.ParentCompanyID,
		arg.CustomFields,
		arg.CompanySize,
		arg.EmployeeCount,
		arg.AnnualRevenue,
		arg.RevenueCurrency,
		arg.CreatedBy,
	)
	var i Company
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Domain,
		&i.Industry,
		&i.Street,
		&i.City,
		&i.State,
		&i.Country,
		&i.PostalCode,
		&i.ParentCompanyID,
		&i.CustomFields,
		&i.CompanySize,
		&i.EmployeeCount,
		&i.AnnualRevenue,
		&i.RevenueCurrency,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getCompaniesByIndustry = `-- name: GetCompaniesByIndustry :many
SELECT id, name, domain, industry, street, city, state, country, postal_code, parent_company_id, custom_fields, company_size, employee_count, annual_revenue, revenue_currency, created_by, updated_by, created_at, updated_at, deleted_at FROM companies 
WHERE industry = $1 AND deleted_at IS NULL
ORDER BY name
`

func (q *Queries) GetCompaniesByIndustry(ctx context.Context, industry *string) ([]Company, error) {
	rows, err := q.db.Query(ctx, getCompaniesByIndustry, industry)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Company{}
	for rows.Next() {
		var i Company
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Domain,
			&i.Industry,
			&i.Street,
			&i.City,
			&i.State,
			&i.Country,
			&i.PostalCode,
			&i.ParentCompanyID,
			&i.CustomFields,
			&i.CompanySize,
			&i.EmployeeCount,
			&i.AnnualRevenue,
			&i.RevenueCurrency,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCompaniesByRevenue = `-- name: GetCompaniesByRevenue :many
SELECT name, annual_revenue, company_size FROM companies 
WHERE annual_revenue > $1 AND deleted_at IS NULL 
ORDER BY annual_revenue DESC
LIMIT $2 OFFSET $3
`

type GetCompaniesByRevenueParams struct {
	AnnualRevenue pgtype.Numeric `json:"annual_revenue"`
	Limit         int32          `json:"limit"`
	Offset        int32          `json:"offset"`
}

type GetCompaniesByRevenueRow struct {
	Name          string         `json:"name"`
	AnnualRevenue pgtype.Numeric `json:"annual_revenue"`
	CompanySize   *string        `json:"company_size"`
}

func (q *Queries) GetCompaniesByRevenue(ctx context.Context, arg GetCompaniesByRevenueParams) ([]GetCompaniesByRevenueRow, error) {
	rows, err := q.db.Query(ctx, getCompaniesByRevenue, arg.AnnualRevenue, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCompaniesByRevenueRow{}
	for rows.Next() {
		var i GetCompaniesByRevenueRow
		if err := rows.Scan(&i.Name, &i.AnnualRevenue, &i.CompanySize); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCompanyByDomain = `-- name: GetCompanyByDomain :one
SELECT id, name, industry FROM companies 
WHERE domain = $1 AND deleted_at IS NULL
`

type GetCompanyByDomainRow struct {
	ID       int32   `json:"id"`
	Name     string  `json:"name"`
	Industry *string `json:"industry"`
}

func (q *Queries) GetCompanyByDomain(ctx context.Context, domain *string) (GetCompanyByDomainRow, error) {
	row := q.db.QueryRow(ctx, getCompanyByDomain, domain)
	var i GetCompanyByDomainRow
	err := row.Scan(&i.ID, &i.Name, &i.Industry)
	return i, err
}

const getCompanyByID = `-- name: GetCompanyByID :one
SELECT id, name, domain, industry, street, city, state, country, postal_code, parent_company_id, custom_fields, company_size, employee_count, annual_revenue, revenue_currency, created_by, updated_by, created_at, updated_at, deleted_at FROM companies 
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetCompanyByID(ctx context.Context, id int32) (Company, error) {
	row := q.db.QueryRow(ctx, getCompanyByID, id)
	var i Company
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Domain,
		&i.Industry,
		&i.Street,
		&i.City,
		&i.State,
		&i.Country,
		&i.PostalCode,
		&i.ParentCompanyID,
		&i.CustomFields,
		&i.CompanySize,
		&i.EmployeeCount,
		&i.AnnualRevenue,
		&i.RevenueCurrency,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getCompanyHierarchy = `-- name: GetCompanyHierarchy :many
WITH RECURSIVE company_tree AS (
    SELECT c.id, c.name, c.parent_company_id, 0 as level 
    FROM companies c WHERE c.id = $1 AND c.deleted_at IS NULL
    UNION ALL
    SELECT c.id, c.name, c.parent_company_id, ct.level + 1
    FROM companies c JOIN company_tree ct ON c.parent_company_id = ct.id
    WHERE c.deleted_at IS NULL
)
SELECT ct.id, ct.name, ct.parent_company_id, ct.level FROM company_tree ct ORDER BY ct.level, ct.name
`

type GetCompanyHierarchyRow struct {
	ID              int32  `json:"id"`
	Name            string `json:"name"`
	ParentCompanyID *int32 `json:"parent_company_id"`
	Level           int32  `json:"level"`
}

func (q *Queries) GetCompanyHierarchy(ctx context.Context, id int32) ([]GetCompanyHierarchyRow, error) {
	rows, err := q.db.Query(ctx, getCompanyHierarchy, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCompanyHierarchyRow{}
	for rows.Next() {
		var i GetCompanyHierarchyRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ParentCompanyID,
			&i.Level,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubsidiaries = `-- name: GetSubsidiaries :many
SELECT id, name, domain, industry, street, city, state, country, postal_code, parent_company_id, custom_fields, company_size, employee_count, annual_revenue, revenue_currency, created_by, updated_by, created_at, updated_at, deleted_at FROM companies 
WHERE parent_company_id = $1 AND deleted_at IS NULL
ORDER BY name
`

func (q *Queries) GetSubsidiaries(ctx context.Context, parentCompanyID *int32) ([]Company, error) {
	rows, err := q.db.Query(ctx, getSubsidiaries, parentCompanyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Company{}
	for rows.Next() {
		var i Company
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Domain,
			&i.Industry,
			&i.Street,
			&i.City,
			&i.State,
			&i.Country,
			&i.PostalCode,
			&i.ParentCompanyID,
			&i.CustomFields,
			&i.CompanySize,
			&i.EmployeeCount,
			&i.AnnualRevenue,
			&i.RevenueCurrency,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCompanies = `-- name: ListCompanies :many
SELECT id, name, domain, industry, street, city, state, country, postal_code, parent_company_id, custom_fields, company_size, employee_count, annual_revenue, revenue_currency, created_by, updated_by, created_at, updated_at, deleted_at FROM companies 
WHERE deleted_at IS NULL 
ORDER BY name 
LIMIT $1 OFFSET $2
`

type ListCompaniesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListCompanies(ctx context.Context, arg ListCompaniesParams) ([]Company, error) {
	rows, err := q.db.Query(ctx, listCompanies, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Company{}
	for rows.Next() {
		var i Company
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Domain,
			&i.Industry,
			&i.Street,
			&i.City,
			&i.State,
			&i.Country,
			&i.PostalCode,
			&i.ParentCompanyID,
			&i.CustomFields,
			&i.CompanySize,
			&i.EmployeeCount,
			&i.AnnualRevenue,
			&i.RevenueCurrency,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchCompaniesByCustomField = `-- name: SearchCompaniesByCustomField :many
SELECT id, name, domain, industry, street, city, state, country, postal_code, parent_company_id, custom_fields, company_size, employee_count, annual_revenue, revenue_currency, created_by, updated_by, created_at, updated_at, deleted_at FROM companies 
WHERE custom_fields->>$1 = $2 AND deleted_at IS NULL
ORDER BY name
`

type SearchCompaniesByCustomFieldParams struct {
	CustomFields   []byte `json:"custom_fields"`
	CustomFields_2 []byte `json:"custom_fields_2"`
}

func (q *Queries) SearchCompaniesByCustomField(ctx context.Context, arg SearchCompaniesByCustomFieldParams) ([]Company, error) {
	rows, err := q.db.Query(ctx, searchCompaniesByCustomField, arg.CustomFields, arg.CustomFields_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Company{}
	for rows.Next() {
		var i Company
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Domain,
			&i.Industry,
			&i.Street,
			&i.City,
			&i.State,
			&i.Country,
			&i.PostalCode,
			&i.ParentCompanyID,
			&i.CustomFields,
			&i.CompanySize,
			&i.EmployeeCount,
			&i.AnnualRevenue,
			&i.RevenueCurrency,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchCompaniesByName = `-- name: SearchCompaniesByName :many
SELECT id, name, domain, industry, street, city, state, country, postal_code, parent_company_id, custom_fields, company_size, employee_count, annual_revenue, revenue_currency, created_by, updated_by, created_at, updated_at, deleted_at FROM companies 
WHERE name ILIKE '%' || $1 || '%' AND deleted_at IS NULL
ORDER BY name
LIMIT $2 OFFSET $3
`

type SearchCompaniesByNameParams struct {
	Column1 *string `json:"column_1"`
	Limit   int32   `json:"limit"`
	Offset  int32   `json:"offset"`
}

func (q *Queries) SearchCompaniesByName(ctx context.Context, arg SearchCompaniesByNameParams) ([]Company, error) {
	rows, err := q.db.Query(ctx, searchCompaniesByName, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Company{}
	for rows.Next() {
		var i Company
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Domain,
			&i.Industry,
			&i.Street,
			&i.City,
			&i.State,
			&i.Country,
			&i.PostalCode,
			&i.ParentCompanyID,
			&i.CustomFields,
			&i.CompanySize,
			&i.EmployeeCount,
			&i.AnnualRevenue,
			&i.RevenueCurrency,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteCompany = `-- name: SoftDeleteCompany :exec
UPDATE companies 
SET deleted_at = CURRENT_TIMESTAMP, updated_by = $2 
WHERE id = $1
`

type SoftDeleteCompanyParams struct {
	ID        int32  `json:"id"`
	UpdatedBy *int32 `json:"updated_by"`
}

func (q *Queries) SoftDeleteCompany(ctx context.Context, arg SoftDeleteCompanyParams) error {
	_, err := q.db.Exec(ctx, softDeleteCompany, arg.ID, arg.UpdatedBy)
	return err
}

const updateCompany = `-- name: UpdateCompany :one
UPDATE companies 
SET name = $2, domain = $3, industry = $4, street = $5, city = $6, 
    state = $7, country = $8, postal_code = $9, parent_company_id = $10,
    custom_fields = $11, company_size = $12, employee_count = $13,
    annual_revenue = $14, revenue_currency = $15, updated_by = $16, 
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, name, domain, industry, street, city, state, country, postal_code, parent_company_id, custom_fields, company_size, employee_count, annual_revenue, revenue_currency, created_by, updated_by, created_at, updated_at, deleted_at
`

type UpdateCompanyParams struct {
	ID              int32          `json:"id"`
	Name            string         `json:"name"`
	Domain          *string        `json:"domain"`
	Industry        *string        `json:"industry"`
	Street          *string        `json:"street"`
	City            *string        `json:"city"`
	State           *string        `json:"state"`
	Country         *string        `json:"country"`
	PostalCode      *string        `json:"postal_code"`
	ParentCompanyID *int32         `json:"parent_company_id"`
	CustomFields    []byte         `json:"custom_fields"`
	CompanySize     *string        `json:"company_size"`
	EmployeeCount   *int32         `json:"employee_count"`
	AnnualRevenue   pgtype.Numeric `json:"annual_revenue"`
	RevenueCurrency *string        `json:"revenue_currency"`
	UpdatedBy       *int32         `json:"updated_by"`
}

func (q *Queries) UpdateCompany(ctx context.Context, arg UpdateCompanyParams) (Company, error) {
	row := q.db.QueryRow(ctx, updateCompany,
		arg.ID,
		arg.Name,
		arg.Domain,
		arg.Industry,
		arg.Street,
		arg.City,
		arg.State,
		arg.Country,
		arg.PostalCode,
		arg.ParentCompanyID,
		arg.CustomFields,
		arg.CompanySize,
		arg.EmployeeCount,
		arg.AnnualRevenue,
		arg.RevenueCurrency,
		arg.UpdatedBy,
	)
	var i Company
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Domain,
		&i.Industry,
		&i.Street,
		&i.City,
		&i.State,
		&i.Country,
		&i.PostalCode,
		&i.ParentCompanyID,
		&i.CustomFields,
		&i.CompanySize,
		&i.EmployeeCount,
		&i.AnnualRevenue,
		&i.RevenueCurrency,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateCompanyCustomFields = `-- name: UpdateCompanyCustomFields :one
UPDATE companies 
SET custom_fields = $2, updated_by = $3, updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, name, domain, industry, street, city, state, country, postal_code, parent_company_id, custom_fields, company_size, employee_count, annual_revenue, revenue_currency, created_by, updated_by, created_at, updated_at, deleted_at
`

type UpdateCompanyCustomFieldsParams struct {
	ID           int32  `json:"id"`
	CustomFields []byte `json:"custom_fields"`
	UpdatedBy    *int32 `json:"updated_by"`
}

func (q *Queries) UpdateCompanyCustomFields(ctx context.Context, arg UpdateCompanyCustomFieldsParams) (Company, error) {
	row := q.db.QueryRow(ctx, updateCompanyCustomFields, arg.ID, arg.CustomFields, arg.UpdatedBy)
	var i Company
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Domain,
		&i.Industry,
		&i.Street,
		&i.City,
		&i.State,
		&i.Country,
		&i.PostalCode,
		&i.ParentCompanyID,
		&i.CustomFields,
		&i.CompanySize,
		&i.EmployeeCount,
		&i.AnnualRevenue,
		&i.RevenueCurrency,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
