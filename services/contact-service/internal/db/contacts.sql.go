// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: contacts.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const countContacts = `-- name: CountContacts :one
SELECT COUNT(*) FROM contacts WHERE deleted_at IS NULL
`

func (q *Queries) CountContacts(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countContacts)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countContactsByCompany = `-- name: CountContactsByCompany :one
SELECT COUNT(*) FROM contacts 
WHERE company_id = $1 AND deleted_at IS NULL
`

func (q *Queries) CountContactsByCompany(ctx context.Context, companyID *int32) (int64, error) {
	row := q.db.QueryRow(ctx, countContactsByCompany, companyID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createContact = `-- name: CreateContact :one
INSERT INTO contacts (
    first_name, last_name, email, phone, company_id, custom_fields, created_by
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, first_name, last_name, email, phone, company_id, custom_fields, deleted_at, created_by, updated_by, created_at, updated_at
`

type CreateContactParams struct {
	FirstName    string  `json:"first_name"`
	LastName     string  `json:"last_name"`
	Email        *string `json:"email"`
	Phone        *string `json:"phone"`
	CompanyID    *int32  `json:"company_id"`
	CustomFields []byte  `json:"custom_fields"`
	CreatedBy    int32   `json:"created_by"`
}

func (q *Queries) CreateContact(ctx context.Context, arg CreateContactParams) (Contact, error) {
	row := q.db.QueryRow(ctx, createContact,
		arg.FirstName,
		arg.LastName,
		arg.Email,
		arg.Phone,
		arg.CompanyID,
		arg.CustomFields,
		arg.CreatedBy,
	)
	var i Contact
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Phone,
		&i.CompanyID,
		&i.CustomFields,
		&i.DeletedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const filterContacts = `-- name: FilterContacts :many
SELECT c.id, c.first_name, c.last_name, c.email, c.phone, c.company_id, c.custom_fields, c.deleted_at, c.created_by, c.updated_by, c.created_at, c.updated_at, comp.name as company_name 
FROM contacts c
LEFT JOIN companies comp ON c.company_id = comp.id AND comp.deleted_at IS NULL
WHERE c.deleted_at IS NULL
  AND ($1::int IS NULL OR c.company_id = $1)
  AND ($2::text IS NULL OR c.custom_fields->>'status' = $2)
ORDER BY c.last_name, c.first_name
LIMIT $3 OFFSET $4
`

type FilterContactsParams struct {
	Column1 int32  `json:"column_1"`
	Column2 string `json:"column_2"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type FilterContactsRow struct {
	ID           int32        `json:"id"`
	FirstName    string       `json:"first_name"`
	LastName     string       `json:"last_name"`
	Email        *string      `json:"email"`
	Phone        *string      `json:"phone"`
	CompanyID    *int32       `json:"company_id"`
	CustomFields []byte       `json:"custom_fields"`
	DeletedAt    sql.NullTime `json:"deleted_at"`
	CreatedBy    int32        `json:"created_by"`
	UpdatedBy    *int32       `json:"updated_by"`
	CreatedAt    time.Time    `json:"created_at"`
	UpdatedAt    time.Time    `json:"updated_at"`
	CompanyName  *string      `json:"company_name"`
}

func (q *Queries) FilterContacts(ctx context.Context, arg FilterContactsParams) ([]FilterContactsRow, error) {
	rows, err := q.db.Query(ctx, filterContacts,
		arg.Column1,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FilterContactsRow{}
	for rows.Next() {
		var i FilterContactsRow
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.Email,
			&i.Phone,
			&i.CompanyID,
			&i.CustomFields,
			&i.DeletedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompanyName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getContactByEmail = `-- name: GetContactByEmail :one
SELECT id, first_name, last_name, company_id FROM contacts 
WHERE email = $1 AND deleted_at IS NULL
`

type GetContactByEmailRow struct {
	ID        int32  `json:"id"`
	FirstName string `json:"first_name"`
	LastName  string `json:"last_name"`
	CompanyID *int32 `json:"company_id"`
}

func (q *Queries) GetContactByEmail(ctx context.Context, email *string) (GetContactByEmailRow, error) {
	row := q.db.QueryRow(ctx, getContactByEmail, email)
	var i GetContactByEmailRow
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.CompanyID,
	)
	return i, err
}

const getContactByID = `-- name: GetContactByID :one
SELECT c.id, c.first_name, c.last_name, c.email, c.phone, c.company_id, c.custom_fields, c.deleted_at, c.created_by, c.updated_by, c.created_at, c.updated_at, comp.name as company_name 
FROM contacts c
LEFT JOIN companies comp ON c.company_id = comp.id AND comp.deleted_at IS NULL
WHERE c.id = $1 AND c.deleted_at IS NULL
`

type GetContactByIDRow struct {
	ID           int32        `json:"id"`
	FirstName    string       `json:"first_name"`
	LastName     string       `json:"last_name"`
	Email        *string      `json:"email"`
	Phone        *string      `json:"phone"`
	CompanyID    *int32       `json:"company_id"`
	CustomFields []byte       `json:"custom_fields"`
	DeletedAt    sql.NullTime `json:"deleted_at"`
	CreatedBy    int32        `json:"created_by"`
	UpdatedBy    *int32       `json:"updated_by"`
	CreatedAt    time.Time    `json:"created_at"`
	UpdatedAt    time.Time    `json:"updated_at"`
	CompanyName  *string      `json:"company_name"`
}

func (q *Queries) GetContactByID(ctx context.Context, id int32) (GetContactByIDRow, error) {
	row := q.db.QueryRow(ctx, getContactByID, id)
	var i GetContactByIDRow
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Phone,
		&i.CompanyID,
		&i.CustomFields,
		&i.DeletedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompanyName,
	)
	return i, err
}

const getContactsByDomain = `-- name: GetContactsByDomain :many
SELECT c.id, c.first_name, c.last_name, c.email, c.phone, c.company_id, c.custom_fields, c.deleted_at, c.created_by, c.updated_by, c.created_at, c.updated_at, comp.name as company_name 
FROM contacts c
LEFT JOIN companies comp ON c.company_id = comp.id AND comp.deleted_at IS NULL
WHERE c.email LIKE '%@' || $1 AND c.deleted_at IS NULL
ORDER BY c.last_name, c.first_name
`

type GetContactsByDomainRow struct {
	ID           int32        `json:"id"`
	FirstName    string       `json:"first_name"`
	LastName     string       `json:"last_name"`
	Email        *string      `json:"email"`
	Phone        *string      `json:"phone"`
	CompanyID    *int32       `json:"company_id"`
	CustomFields []byte       `json:"custom_fields"`
	DeletedAt    sql.NullTime `json:"deleted_at"`
	CreatedBy    int32        `json:"created_by"`
	UpdatedBy    *int32       `json:"updated_by"`
	CreatedAt    time.Time    `json:"created_at"`
	UpdatedAt    time.Time    `json:"updated_at"`
	CompanyName  *string      `json:"company_name"`
}

func (q *Queries) GetContactsByDomain(ctx context.Context, dollar_1 *string) ([]GetContactsByDomainRow, error) {
	rows, err := q.db.Query(ctx, getContactsByDomain, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetContactsByDomainRow{}
	for rows.Next() {
		var i GetContactsByDomainRow
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.Email,
			&i.Phone,
			&i.CompanyID,
			&i.CustomFields,
			&i.DeletedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompanyName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listContacts = `-- name: ListContacts :many
SELECT c.id, c.first_name, c.last_name, c.email, c.phone, c.company_id, c.custom_fields, c.deleted_at, c.created_by, c.updated_by, c.created_at, c.updated_at, comp.name as company_name 
FROM contacts c
LEFT JOIN companies comp ON c.company_id = comp.id AND comp.deleted_at IS NULL
WHERE c.deleted_at IS NULL
ORDER BY c.last_name, c.first_name
LIMIT $1 OFFSET $2
`

type ListContactsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListContactsRow struct {
	ID           int32        `json:"id"`
	FirstName    string       `json:"first_name"`
	LastName     string       `json:"last_name"`
	Email        *string      `json:"email"`
	Phone        *string      `json:"phone"`
	CompanyID    *int32       `json:"company_id"`
	CustomFields []byte       `json:"custom_fields"`
	DeletedAt    sql.NullTime `json:"deleted_at"`
	CreatedBy    int32        `json:"created_by"`
	UpdatedBy    *int32       `json:"updated_by"`
	CreatedAt    time.Time    `json:"created_at"`
	UpdatedAt    time.Time    `json:"updated_at"`
	CompanyName  *string      `json:"company_name"`
}

func (q *Queries) ListContacts(ctx context.Context, arg ListContactsParams) ([]ListContactsRow, error) {
	rows, err := q.db.Query(ctx, listContacts, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListContactsRow{}
	for rows.Next() {
		var i ListContactsRow
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.Email,
			&i.Phone,
			&i.CompanyID,
			&i.CustomFields,
			&i.DeletedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompanyName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listContactsByCompany = `-- name: ListContactsByCompany :many
SELECT id, first_name, last_name, email, phone, company_id, custom_fields, deleted_at, created_by, updated_by, created_at, updated_at FROM contacts 
WHERE company_id = $1 AND deleted_at IS NULL
ORDER BY last_name, first_name
`

func (q *Queries) ListContactsByCompany(ctx context.Context, companyID *int32) ([]Contact, error) {
	rows, err := q.db.Query(ctx, listContactsByCompany, companyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Contact{}
	for rows.Next() {
		var i Contact
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.Email,
			&i.Phone,
			&i.CompanyID,
			&i.CustomFields,
			&i.DeletedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchContactsByCustomField = `-- name: SearchContactsByCustomField :many
SELECT id, first_name, last_name, email, phone, company_id, custom_fields, deleted_at, created_by, updated_by, created_at, updated_at FROM contacts 
WHERE custom_fields->>$1 = $2 AND deleted_at IS NULL
ORDER BY last_name, first_name
`

type SearchContactsByCustomFieldParams struct {
	CustomFields   []byte `json:"custom_fields"`
	CustomFields_2 []byte `json:"custom_fields_2"`
}

func (q *Queries) SearchContactsByCustomField(ctx context.Context, arg SearchContactsByCustomFieldParams) ([]Contact, error) {
	rows, err := q.db.Query(ctx, searchContactsByCustomField, arg.CustomFields, arg.CustomFields_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Contact{}
	for rows.Next() {
		var i Contact
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.Email,
			&i.Phone,
			&i.CompanyID,
			&i.CustomFields,
			&i.DeletedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchContactsFullText = `-- name: SearchContactsFullText :many
SELECT c.id, c.first_name, c.last_name, c.email, c.phone, c.company_id, c.custom_fields, c.deleted_at, c.created_by, c.updated_by, c.created_at, c.updated_at, comp.name as company_name 
FROM contacts c
LEFT JOIN companies comp ON c.company_id = comp.id AND comp.deleted_at IS NULL
WHERE c.deleted_at IS NULL 
  AND to_tsvector('english', c.first_name || ' ' || c.last_name || ' ' || COALESCE(c.email, '')) 
      @@ to_tsquery('english', $1)
ORDER BY c.last_name, c.first_name
LIMIT $2 OFFSET $3
`

type SearchContactsFullTextParams struct {
	ToTsquery string `json:"to_tsquery"`
	Limit     int32  `json:"limit"`
	Offset    int32  `json:"offset"`
}

type SearchContactsFullTextRow struct {
	ID           int32        `json:"id"`
	FirstName    string       `json:"first_name"`
	LastName     string       `json:"last_name"`
	Email        *string      `json:"email"`
	Phone        *string      `json:"phone"`
	CompanyID    *int32       `json:"company_id"`
	CustomFields []byte       `json:"custom_fields"`
	DeletedAt    sql.NullTime `json:"deleted_at"`
	CreatedBy    int32        `json:"created_by"`
	UpdatedBy    *int32       `json:"updated_by"`
	CreatedAt    time.Time    `json:"created_at"`
	UpdatedAt    time.Time    `json:"updated_at"`
	CompanyName  *string      `json:"company_name"`
}

func (q *Queries) SearchContactsFullText(ctx context.Context, arg SearchContactsFullTextParams) ([]SearchContactsFullTextRow, error) {
	rows, err := q.db.Query(ctx, searchContactsFullText, arg.ToTsquery, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchContactsFullTextRow{}
	for rows.Next() {
		var i SearchContactsFullTextRow
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.Email,
			&i.Phone,
			&i.CompanyID,
			&i.CustomFields,
			&i.DeletedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompanyName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteContact = `-- name: SoftDeleteContact :exec
UPDATE contacts 
SET deleted_at = CURRENT_TIMESTAMP, updated_by = $2 
WHERE id = $1
`

type SoftDeleteContactParams struct {
	ID        int32  `json:"id"`
	UpdatedBy *int32 `json:"updated_by"`
}

func (q *Queries) SoftDeleteContact(ctx context.Context, arg SoftDeleteContactParams) error {
	_, err := q.db.Exec(ctx, softDeleteContact, arg.ID, arg.UpdatedBy)
	return err
}

const updateContact = `-- name: UpdateContact :one
UPDATE contacts 
SET first_name = $2, last_name = $3, email = $4, phone = $5, 
    company_id = $6, custom_fields = $7, updated_by = $8, 
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, first_name, last_name, email, phone, company_id, custom_fields, deleted_at, created_by, updated_by, created_at, updated_at
`

type UpdateContactParams struct {
	ID           int32   `json:"id"`
	FirstName    string  `json:"first_name"`
	LastName     string  `json:"last_name"`
	Email        *string `json:"email"`
	Phone        *string `json:"phone"`
	CompanyID    *int32  `json:"company_id"`
	CustomFields []byte  `json:"custom_fields"`
	UpdatedBy    *int32  `json:"updated_by"`
}

func (q *Queries) UpdateContact(ctx context.Context, arg UpdateContactParams) (Contact, error) {
	row := q.db.QueryRow(ctx, updateContact,
		arg.ID,
		arg.FirstName,
		arg.LastName,
		arg.Email,
		arg.Phone,
		arg.CompanyID,
		arg.CustomFields,
		arg.UpdatedBy,
	)
	var i Contact
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Phone,
		&i.CompanyID,
		&i.CustomFields,
		&i.DeletedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateContactCustomFields = `-- name: UpdateContactCustomFields :one
UPDATE contacts 
SET custom_fields = $2, updated_by = $3, updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, first_name, last_name, email, phone, company_id, custom_fields, deleted_at, created_by, updated_by, created_at, updated_at
`

type UpdateContactCustomFieldsParams struct {
	ID           int32  `json:"id"`
	CustomFields []byte `json:"custom_fields"`
	UpdatedBy    *int32 `json:"updated_by"`
}

func (q *Queries) UpdateContactCustomFields(ctx context.Context, arg UpdateContactCustomFieldsParams) (Contact, error) {
	row := q.db.QueryRow(ctx, updateContactCustomFields, arg.ID, arg.CustomFields, arg.UpdatedBy)
	var i Contact
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Phone,
		&i.CompanyID,
		&i.CustomFields,
		&i.DeletedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
