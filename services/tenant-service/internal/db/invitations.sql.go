// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: invitations.sql

package db

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"
)

const acceptInvitation = `-- name: AcceptInvitation :exec
UPDATE invitations
SET accepted_at = CURRENT_TIMESTAMP
WHERE token = $1 AND accepted_at IS NULL
`

func (q *Queries) AcceptInvitation(ctx context.Context, token string) error {
	_, err := q.db.Exec(ctx, acceptInvitation, token)
	return err
}

const checkPendingInvitation = `-- name: CheckPendingInvitation :one
SELECT EXISTS(
    SELECT 1 FROM invitations 
    WHERE tenant_id = $1 
      AND email = $2 
      AND accepted_at IS NULL 
      AND expires_at > CURRENT_TIMESTAMP
)
`

type CheckPendingInvitationParams struct {
	TenantID *int32 `json:"tenant_id"`
	Email    string `json:"email"`
}

func (q *Queries) CheckPendingInvitation(ctx context.Context, arg CheckPendingInvitationParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkPendingInvitation, arg.TenantID, arg.Email)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const cleanupExpiredInvitations = `-- name: CleanupExpiredInvitations :exec
DELETE FROM invitations
WHERE expires_at < CURRENT_TIMESTAMP
`

func (q *Queries) CleanupExpiredInvitations(ctx context.Context) error {
	_, err := q.db.Exec(ctx, cleanupExpiredInvitations)
	return err
}

const createInvitation = `-- name: CreateInvitation :one
INSERT INTO invitations (tenant_id, email, role, token, expires_at, invited_by, metadata)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, token, expires_at, created_at
`

type CreateInvitationParams struct {
	TenantID  *int32          `json:"tenant_id"`
	Email     string          `json:"email"`
	Role      string          `json:"role"`
	Token     string          `json:"token"`
	ExpiresAt time.Time       `json:"expires_at"`
	InvitedBy *int32          `json:"invited_by"`
	Metadata  json.RawMessage `json:"metadata"`
}

type CreateInvitationRow struct {
	ID        int32     `json:"id"`
	Token     string    `json:"token"`
	ExpiresAt time.Time `json:"expires_at"`
	CreatedAt time.Time `json:"created_at"`
}

func (q *Queries) CreateInvitation(ctx context.Context, arg CreateInvitationParams) (CreateInvitationRow, error) {
	row := q.db.QueryRow(ctx, createInvitation,
		arg.TenantID,
		arg.Email,
		arg.Role,
		arg.Token,
		arg.ExpiresAt,
		arg.InvitedBy,
		arg.Metadata,
	)
	var i CreateInvitationRow
	err := row.Scan(
		&i.ID,
		&i.Token,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const getInvitationByToken = `-- name: GetInvitationByToken :one
SELECT i.id, i.tenant_id, i.email, i.role, i.token, i.expires_at, i.accepted_at, i.metadata,
       t.name as tenant_name, t.subdomain as tenant_subdomain, t.schema_name as tenant_schema
FROM invitations i
JOIN tenants t ON i.tenant_id = t.id
WHERE i.token = $1 
  AND i.accepted_at IS NULL 
  AND i.expires_at > CURRENT_TIMESTAMP
`

type GetInvitationByTokenRow struct {
	ID              int32           `json:"id"`
	TenantID        *int32          `json:"tenant_id"`
	Email           string          `json:"email"`
	Role            string          `json:"role"`
	Token           string          `json:"token"`
	ExpiresAt       time.Time       `json:"expires_at"`
	AcceptedAt      sql.NullTime    `json:"accepted_at"`
	Metadata        json.RawMessage `json:"metadata"`
	TenantName      string          `json:"tenant_name"`
	TenantSubdomain string          `json:"tenant_subdomain"`
	TenantSchema    string          `json:"tenant_schema"`
}

func (q *Queries) GetInvitationByToken(ctx context.Context, token string) (GetInvitationByTokenRow, error) {
	row := q.db.QueryRow(ctx, getInvitationByToken, token)
	var i GetInvitationByTokenRow
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Email,
		&i.Role,
		&i.Token,
		&i.ExpiresAt,
		&i.AcceptedAt,
		&i.Metadata,
		&i.TenantName,
		&i.TenantSubdomain,
		&i.TenantSchema,
	)
	return i, err
}

const getInvitationsByEmail = `-- name: GetInvitationsByEmail :many
SELECT i.id, i.tenant_id, i.role, i.token, i.expires_at, i.accepted_at,
       t.name as tenant_name, t.subdomain as tenant_subdomain
FROM invitations i
JOIN tenants t ON i.tenant_id = t.id
WHERE i.email = $1
ORDER BY i.created_at DESC
`

type GetInvitationsByEmailRow struct {
	ID              int32        `json:"id"`
	TenantID        *int32       `json:"tenant_id"`
	Role            string       `json:"role"`
	Token           string       `json:"token"`
	ExpiresAt       time.Time    `json:"expires_at"`
	AcceptedAt      sql.NullTime `json:"accepted_at"`
	TenantName      string       `json:"tenant_name"`
	TenantSubdomain string       `json:"tenant_subdomain"`
}

func (q *Queries) GetInvitationsByEmail(ctx context.Context, email string) ([]GetInvitationsByEmailRow, error) {
	rows, err := q.db.Query(ctx, getInvitationsByEmail, email)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetInvitationsByEmailRow{}
	for rows.Next() {
		var i GetInvitationsByEmailRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Role,
			&i.Token,
			&i.ExpiresAt,
			&i.AcceptedAt,
			&i.TenantName,
			&i.TenantSubdomain,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingInvitations = `-- name: ListPendingInvitations :many
SELECT i.id, i.email, i.role, i.expires_at, i.created_at,
       t.name as tenant_name, t.subdomain as tenant_subdomain
FROM invitations i
JOIN tenants t ON i.tenant_id = t.id
WHERE i.accepted_at IS NULL 
  AND i.expires_at > CURRENT_TIMESTAMP
ORDER BY i.created_at DESC
`

type ListPendingInvitationsRow struct {
	ID              int32     `json:"id"`
	Email           string    `json:"email"`
	Role            string    `json:"role"`
	ExpiresAt       time.Time `json:"expires_at"`
	CreatedAt       time.Time `json:"created_at"`
	TenantName      string    `json:"tenant_name"`
	TenantSubdomain string    `json:"tenant_subdomain"`
}

func (q *Queries) ListPendingInvitations(ctx context.Context) ([]ListPendingInvitationsRow, error) {
	rows, err := q.db.Query(ctx, listPendingInvitations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPendingInvitationsRow{}
	for rows.Next() {
		var i ListPendingInvitationsRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Role,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.TenantName,
			&i.TenantSubdomain,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTenantInvitations = `-- name: ListTenantInvitations :many
SELECT id, email, role, token, expires_at, accepted_at, created_at
FROM invitations
WHERE tenant_id = $1
ORDER BY created_at DESC
`

type ListTenantInvitationsRow struct {
	ID         int32        `json:"id"`
	Email      string       `json:"email"`
	Role       string       `json:"role"`
	Token      string       `json:"token"`
	ExpiresAt  time.Time    `json:"expires_at"`
	AcceptedAt sql.NullTime `json:"accepted_at"`
	CreatedAt  time.Time    `json:"created_at"`
}

func (q *Queries) ListTenantInvitations(ctx context.Context, tenantID *int32) ([]ListTenantInvitationsRow, error) {
	rows, err := q.db.Query(ctx, listTenantInvitations, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTenantInvitationsRow{}
	for rows.Next() {
		var i ListTenantInvitationsRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Role,
			&i.Token,
			&i.ExpiresAt,
			&i.AcceptedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const revokeInvitation = `-- name: RevokeInvitation :exec
DELETE FROM invitations
WHERE id = $1 AND tenant_id = $2 AND accepted_at IS NULL
`

type RevokeInvitationParams struct {
	ID       int32  `json:"id"`
	TenantID *int32 `json:"tenant_id"`
}

func (q *Queries) RevokeInvitation(ctx context.Context, arg RevokeInvitationParams) error {
	_, err := q.db.Exec(ctx, revokeInvitation, arg.ID, arg.TenantID)
	return err
}
