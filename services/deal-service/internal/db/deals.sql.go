// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: deals.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const closeDeal = `-- name: CloseDeal :one
UPDATE deals 
SET stage = $2, actual_close_date = $3, updated_at = NOW()
WHERE id = $1
RETURNING id, title, description, value, currency, stage, probability, expected_close_date, actual_close_date, owner_id, company_id, primary_contact_id, source, close_reason, custom_fields, created_at, updated_at, created_by
`

type CloseDealParams struct {
	ID              int32        `json:"id"`
	Stage           string       `json:"stage"`
	ActualCloseDate sql.NullTime `json:"actual_close_date"`
}

func (q *Queries) CloseDeal(ctx context.Context, arg CloseDealParams) (Deal, error) {
	row := q.db.QueryRow(ctx, closeDeal, arg.ID, arg.Stage, arg.ActualCloseDate)
	var i Deal
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Value,
		&i.Currency,
		&i.Stage,
		&i.Probability,
		&i.ExpectedCloseDate,
		&i.ActualCloseDate,
		&i.OwnerID,
		&i.CompanyID,
		&i.PrimaryContactID,
		&i.Source,
		&i.CloseReason,
		&i.CustomFields,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const countDeals = `-- name: CountDeals :one
SELECT COUNT(*) FROM deals
`

func (q *Queries) CountDeals(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countDeals)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createDeal = `-- name: CreateDeal :one
INSERT INTO deals (
    title, value, probability, stage, primary_contact_id, company_id, 
    owner_id, expected_close_date, source, description, created_by
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
) RETURNING id, title, description, value, currency, stage, probability, expected_close_date, actual_close_date, owner_id, company_id, primary_contact_id, source, close_reason, custom_fields, created_at, updated_at, created_by
`

type CreateDealParams struct {
	Title             string         `json:"title"`
	Value             pgtype.Numeric `json:"value"`
	Probability       *int32         `json:"probability"`
	Stage             string         `json:"stage"`
	PrimaryContactID  *int32         `json:"primary_contact_id"`
	CompanyID         *int32         `json:"company_id"`
	OwnerID           *int32         `json:"owner_id"`
	ExpectedCloseDate sql.NullTime   `json:"expected_close_date"`
	Source            *string        `json:"source"`
	Description       *string        `json:"description"`
	CreatedBy         *int32         `json:"created_by"`
}

func (q *Queries) CreateDeal(ctx context.Context, arg CreateDealParams) (Deal, error) {
	row := q.db.QueryRow(ctx, createDeal,
		arg.Title,
		arg.Value,
		arg.Probability,
		arg.Stage,
		arg.PrimaryContactID,
		arg.CompanyID,
		arg.OwnerID,
		arg.ExpectedCloseDate,
		arg.Source,
		arg.Description,
		arg.CreatedBy,
	)
	var i Deal
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Value,
		&i.Currency,
		&i.Stage,
		&i.Probability,
		&i.ExpectedCloseDate,
		&i.ActualCloseDate,
		&i.OwnerID,
		&i.CompanyID,
		&i.PrimaryContactID,
		&i.Source,
		&i.CloseReason,
		&i.CustomFields,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const deleteDeal = `-- name: DeleteDeal :execrows
DELETE FROM deals WHERE id = $1
`

func (q *Queries) DeleteDeal(ctx context.Context, id int32) (int64, error) {
	result, err := q.db.Exec(ctx, deleteDeal, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getDealByID = `-- name: GetDealByID :one
SELECT d.id, d.title, d.description, d.value, d.currency, d.stage, d.probability, d.expected_close_date, d.actual_close_date, d.owner_id, d.company_id, d.primary_contact_id, d.source, d.close_reason, d.custom_fields, d.created_at, d.updated_at, d.created_by, 
       c.first_name || ' ' || c.last_name as primary_contact_name,
       comp.name as company_name,
       u.first_name || ' ' || u.last_name as owner_name
FROM deals d
LEFT JOIN contacts c ON d.primary_contact_id = c.id
LEFT JOIN companies comp ON d.company_id = comp.id
LEFT JOIN users u ON d.owner_id = u.id AND u.status = 'active'
WHERE d.id = $1
`

type GetDealByIDRow struct {
	ID                 int32          `json:"id"`
	Title              string         `json:"title"`
	Description        *string        `json:"description"`
	Value              pgtype.Numeric `json:"value"`
	Currency           *string        `json:"currency"`
	Stage              string         `json:"stage"`
	Probability        *int32         `json:"probability"`
	ExpectedCloseDate  sql.NullTime   `json:"expected_close_date"`
	ActualCloseDate    sql.NullTime   `json:"actual_close_date"`
	OwnerID            *int32         `json:"owner_id"`
	CompanyID          *int32         `json:"company_id"`
	PrimaryContactID   *int32         `json:"primary_contact_id"`
	Source             *string        `json:"source"`
	CloseReason        *string        `json:"close_reason"`
	CustomFields       []byte         `json:"custom_fields"`
	CreatedAt          time.Time      `json:"created_at"`
	UpdatedAt          time.Time      `json:"updated_at"`
	CreatedBy          *int32         `json:"created_by"`
	PrimaryContactName interface{}    `json:"primary_contact_name"`
	CompanyName        *string        `json:"company_name"`
	OwnerName          interface{}    `json:"owner_name"`
}

func (q *Queries) GetDealByID(ctx context.Context, id int32) (GetDealByIDRow, error) {
	row := q.db.QueryRow(ctx, getDealByID, id)
	var i GetDealByIDRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Value,
		&i.Currency,
		&i.Stage,
		&i.Probability,
		&i.ExpectedCloseDate,
		&i.ActualCloseDate,
		&i.OwnerID,
		&i.CompanyID,
		&i.PrimaryContactID,
		&i.Source,
		&i.CloseReason,
		&i.CustomFields,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.PrimaryContactName,
		&i.CompanyName,
		&i.OwnerName,
	)
	return i, err
}

const getDealsByOwner = `-- name: GetDealsByOwner :many
SELECT id, title, description, value, currency, stage, probability, expected_close_date, actual_close_date, owner_id, company_id, primary_contact_id, source, close_reason, custom_fields, created_at, updated_at, created_by FROM deals 
WHERE owner_id = $1 AND actual_close_date IS NULL
ORDER BY expected_close_date ASC
`

func (q *Queries) GetDealsByOwner(ctx context.Context, ownerID *int32) ([]Deal, error) {
	rows, err := q.db.Query(ctx, getDealsByOwner, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Deal{}
	for rows.Next() {
		var i Deal
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Value,
			&i.Currency,
			&i.Stage,
			&i.Probability,
			&i.ExpectedCloseDate,
			&i.ActualCloseDate,
			&i.OwnerID,
			&i.CompanyID,
			&i.PrimaryContactID,
			&i.Source,
			&i.CloseReason,
			&i.CustomFields,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDealsByStage = `-- name: GetDealsByStage :many
SELECT stage, COUNT(*) as deal_count, 
       COALESCE(SUM(value), 0) as total_value,
       COALESCE(SUM(value * probability / 100), 0) as weighted_value
FROM deals 
WHERE actual_close_date IS NULL
GROUP BY stage 
ORDER BY 
    CASE stage
        WHEN 'Lead' THEN 1
        WHEN 'Qualified' THEN 2
        WHEN 'Proposal' THEN 3
        WHEN 'Negotiation' THEN 4
        WHEN 'Closed Won' THEN 5
        WHEN 'Closed Lost' THEN 6
        ELSE 99
    END
`

type GetDealsByStageRow struct {
	Stage         string      `json:"stage"`
	DealCount     int64       `json:"deal_count"`
	TotalValue    interface{} `json:"total_value"`
	WeightedValue interface{} `json:"weighted_value"`
}

func (q *Queries) GetDealsByStage(ctx context.Context) ([]GetDealsByStageRow, error) {
	rows, err := q.db.Query(ctx, getDealsByStage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDealsByStageRow{}
	for rows.Next() {
		var i GetDealsByStageRow
		if err := rows.Scan(
			&i.Stage,
			&i.DealCount,
			&i.TotalValue,
			&i.WeightedValue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonthlyForecast = `-- name: GetMonthlyForecast :many
SELECT 
    DATE_TRUNC('month', expected_close_date) as forecast_month,
    SUM(value * probability / 100) as expected_revenue,
    COUNT(*) as deal_count
FROM deals 
WHERE actual_close_date IS NULL AND expected_close_date IS NOT NULL
GROUP BY DATE_TRUNC('month', expected_close_date)
ORDER BY forecast_month
`

type GetMonthlyForecastRow struct {
	ForecastMonth   pgtype.Interval `json:"forecast_month"`
	ExpectedRevenue int64           `json:"expected_revenue"`
	DealCount       int64           `json:"deal_count"`
}

func (q *Queries) GetMonthlyForecast(ctx context.Context) ([]GetMonthlyForecastRow, error) {
	rows, err := q.db.Query(ctx, getMonthlyForecast)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMonthlyForecastRow{}
	for rows.Next() {
		var i GetMonthlyForecastRow
		if err := rows.Scan(&i.ForecastMonth, &i.ExpectedRevenue, &i.DealCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSalesRepPerformance = `-- name: GetSalesRepPerformance :many
SELECT u.first_name, u.last_name, COUNT(*) as deals_closed, SUM(d.value) as total_revenue
FROM deals d
JOIN users u ON d.owner_id = u.id
WHERE d.actual_close_date >= $1 AND d.stage = 'Closed Won'
GROUP BY u.id, u.first_name, u.last_name
ORDER BY total_revenue DESC
`

type GetSalesRepPerformanceRow struct {
	FirstName    string `json:"first_name"`
	LastName     string `json:"last_name"`
	DealsClosed  int64  `json:"deals_closed"`
	TotalRevenue int64  `json:"total_revenue"`
}

func (q *Queries) GetSalesRepPerformance(ctx context.Context, actualCloseDate sql.NullTime) ([]GetSalesRepPerformanceRow, error) {
	rows, err := q.db.Query(ctx, getSalesRepPerformance, actualCloseDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSalesRepPerformanceRow{}
	for rows.Next() {
		var i GetSalesRepPerformanceRow
		if err := rows.Scan(
			&i.FirstName,
			&i.LastName,
			&i.DealsClosed,
			&i.TotalRevenue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDeals = `-- name: ListDeals :many
SELECT d.id, d.title, d.description, d.value, d.currency, d.stage, d.probability, d.expected_close_date, d.actual_close_date, d.owner_id, d.company_id, d.primary_contact_id, d.source, d.close_reason, d.custom_fields, d.created_at, d.updated_at, d.created_by, 
       c.first_name || ' ' || c.last_name as primary_contact_name,
       comp.name as company_name,
       u.first_name || ' ' || u.last_name as owner_name
FROM deals d
LEFT JOIN contacts c ON d.primary_contact_id = c.id
LEFT JOIN companies comp ON d.company_id = comp.id
LEFT JOIN users u ON d.owner_id = u.id AND u.status = 'active'
ORDER BY d.created_at DESC
LIMIT $1 OFFSET $2
`

type ListDealsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListDealsRow struct {
	ID                 int32          `json:"id"`
	Title              string         `json:"title"`
	Description        *string        `json:"description"`
	Value              pgtype.Numeric `json:"value"`
	Currency           *string        `json:"currency"`
	Stage              string         `json:"stage"`
	Probability        *int32         `json:"probability"`
	ExpectedCloseDate  sql.NullTime   `json:"expected_close_date"`
	ActualCloseDate    sql.NullTime   `json:"actual_close_date"`
	OwnerID            *int32         `json:"owner_id"`
	CompanyID          *int32         `json:"company_id"`
	PrimaryContactID   *int32         `json:"primary_contact_id"`
	Source             *string        `json:"source"`
	CloseReason        *string        `json:"close_reason"`
	CustomFields       []byte         `json:"custom_fields"`
	CreatedAt          time.Time      `json:"created_at"`
	UpdatedAt          time.Time      `json:"updated_at"`
	CreatedBy          *int32         `json:"created_by"`
	PrimaryContactName interface{}    `json:"primary_contact_name"`
	CompanyName        *string        `json:"company_name"`
	OwnerName          interface{}    `json:"owner_name"`
}

func (q *Queries) ListDeals(ctx context.Context, arg ListDealsParams) ([]ListDealsRow, error) {
	rows, err := q.db.Query(ctx, listDeals, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListDealsRow{}
	for rows.Next() {
		var i ListDealsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Value,
			&i.Currency,
			&i.Stage,
			&i.Probability,
			&i.ExpectedCloseDate,
			&i.ActualCloseDate,
			&i.OwnerID,
			&i.CompanyID,
			&i.PrimaryContactID,
			&i.Source,
			&i.CloseReason,
			&i.CustomFields,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.PrimaryContactName,
			&i.CompanyName,
			&i.OwnerName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateDeal = `-- name: UpdateDeal :one
UPDATE deals 
SET title = $2, value = $3, probability = $4, stage = $5,
    primary_contact_id = $6, company_id = $7, owner_id = $8,
    expected_close_date = $9, source = $10, description = $11,
    updated_at = NOW()
WHERE id = $1
RETURNING id, title, description, value, currency, stage, probability, expected_close_date, actual_close_date, owner_id, company_id, primary_contact_id, source, close_reason, custom_fields, created_at, updated_at, created_by
`

type UpdateDealParams struct {
	ID                int32          `json:"id"`
	Title             string         `json:"title"`
	Value             pgtype.Numeric `json:"value"`
	Probability       *int32         `json:"probability"`
	Stage             string         `json:"stage"`
	PrimaryContactID  *int32         `json:"primary_contact_id"`
	CompanyID         *int32         `json:"company_id"`
	OwnerID           *int32         `json:"owner_id"`
	ExpectedCloseDate sql.NullTime   `json:"expected_close_date"`
	Source            *string        `json:"source"`
	Description       *string        `json:"description"`
}

func (q *Queries) UpdateDeal(ctx context.Context, arg UpdateDealParams) (Deal, error) {
	row := q.db.QueryRow(ctx, updateDeal,
		arg.ID,
		arg.Title,
		arg.Value,
		arg.Probability,
		arg.Stage,
		arg.PrimaryContactID,
		arg.CompanyID,
		arg.OwnerID,
		arg.ExpectedCloseDate,
		arg.Source,
		arg.Description,
	)
	var i Deal
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Value,
		&i.Currency,
		&i.Stage,
		&i.Probability,
		&i.ExpectedCloseDate,
		&i.ActualCloseDate,
		&i.OwnerID,
		&i.CompanyID,
		&i.PrimaryContactID,
		&i.Source,
		&i.CloseReason,
		&i.CustomFields,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
	)
	return i, err
}
